diff --git a/include/gs-mm.h b/include/gs-mm.h
index f33feca..f8a766d 100644
--- a/include/gs-mm.h
+++ b/include/gs-mm.h
@@ -1,10 +1,12 @@
 #ifndef _GS_MM_H
 #define _GS_MM_H
 
-#define WS_MAX 1024 * 4
+#define MAX 200000
 
-extern unsigned long *addr_list;
-extern unsigned long addr_list_size;
+extern unsigned long *ws;
+extern unsigned long ws_size;
+extern unsigned long *ds;
+extern unsigned long ds_size;
 
 extern int clear_collect_ws(int nr);
 
diff --git a/src/gs-interface.c b/src/gs-interface.c
index 0a02f6a..df68a06 100644
--- a/src/gs-interface.c
+++ b/src/gs-interface.c
@@ -55,11 +55,15 @@ gs_read(        struct file *file,
                 size_t length,
                 loff_t *offset)
 {
-        if (length == sizeof(int)) {
-                copy_to_user(buffer, &addr_list_size, sizeof(int));
+        if (length == 2*sizeof(int)) {
+                copy_to_user(buffer, &ws_size, sizeof(int));
+                copy_to_user(buffer + sizeof(int), &ds_size, sizeof(int));
         }
-        else if (length == addr_list_size * sizeof(unsigned long)) {
-                copy_to_user(buffer, addr_list, addr_list_size * sizeof(unsigned long));
+        else if (length == ws_size * sizeof(unsigned long)) {
+                copy_to_user(buffer, ws, ws_size * sizeof(unsigned long));
+        }
+        else if (length == ds_size * sizeof(unsigned long)) {
+                copy_to_user(buffer, ds, ds_size * sizeof(unsigned long));
         }
         else {
                 return -EINVAL;
diff --git a/src/gs-mm.c b/src/gs-mm.c
index eb99729..26cdd28 100644
--- a/src/gs-mm.c
+++ b/src/gs-mm.c
@@ -6,8 +6,10 @@
 #include "gs-log.h"
 #include "gs-mm.h"
 
-unsigned long *addr_list = NULL;
-unsigned long addr_list_size = 0;
+unsigned long *ws = NULL;
+unsigned long ws_size = 0;
+unsigned long *ds = NULL;
+unsigned long ds_size = 0;
 
 struct gs_walk_params {
         char clear;
@@ -26,13 +28,22 @@ gs_walk_pte_entry(pte_t *ptep, unsigned long addr,
         if (gwp->clear && pte_young(pte)) {
                 set_page_young(page);
 
-                set_pte(ptep, pte_mkold(pte));
+                pte = pte_mkold(pte);
+                set_pte(ptep, pte);
         }
 
-        if (gwp->clear && (pte_young(pte) || !page_is_idle(page))) {
-                if (addr_list_size < WS_MAX) {
-                        addr_list[addr_list_size] = addr;
-                        addr_list_size++;
+        if (gwp->clear) {
+                if ((pte_young(pte) || !page_is_idle(page))) {
+                        if (ws_size < MAX) {
+                                ws[ws_size] = addr;
+                                ws_size++;
+                        }
+                }
+                if (pte_dirty(pte) || pte_soft_dirty(pte)) {
+                        if (ds_size < MAX) {
+                                ds[ds_size] = addr;
+                                ds_size++;
+                        }
                 }
         }
 
@@ -43,8 +54,10 @@ gs_walk_pte_entry(pte_t *ptep, unsigned long addr,
         gwp->count += (pte_young(pte) || !page_is_idle(page)) ? 1 : 0;
 
         // In any case, set idleness
-        if (gwp->clear)
+        if (gwp->clear) {
                 set_page_idle(page);
+                set_pte(ptep, pte_mkclean(pte));
+        }
 
         return 0;
 }
@@ -86,7 +99,8 @@ clear_collect_ws(int nr)
         if (!task)
                 return -1;
 
-        addr_list_size = 0;
+        ws_size = 0;
+        ds_size = 0;
 
         mm = task->mm;
 
diff --git a/src/gunslinger.c b/src/gunslinger.c
index 02c43a1..191b806 100644
--- a/src/gunslinger.c
+++ b/src/gunslinger.c
@@ -29,8 +29,13 @@ gsm_init(void)
         gs_log("successfully loaded module");
         gs_log("major number is %d", major);
 
-        addr_list = kmalloc(WS_MAX * sizeof(unsigned long), GFP_KERNEL);
-        if (!addr_list) {
+        ws = kmalloc(MAX * sizeof(unsigned long), GFP_KERNEL);
+        if (!ws) {
+                gs_log("unable to allocate memory");
+                return 1;
+        }
+        ds = kmalloc(MAX * sizeof(unsigned long), GFP_KERNEL);
+        if (!ds) {
                 gs_log("unable to allocate memory");
                 return 1;
         }
@@ -41,7 +46,8 @@ gsm_init(void)
 static void __exit
 gsm_exit(void)
 {
-        kfree(addr_list);
+        kfree(ws);
+        kfree(ds);
 
         unregister_chrdev(major, DEVICENAME);
         gs_log("bye bye!");
diff --git a/test/main.c b/test/main.c
index db5a3f1..2347249 100644
--- a/test/main.c
+++ b/test/main.c
@@ -5,16 +5,19 @@
 #include <sys/mman.h>
 #include <unistd.h>
 
-#define SIZE 200000
+#define SIZE 20000
 
 int main()
 {
 
         char *buf1, *buf2, *buf3;
-        unsigned long i;
+        unsigned long i, j;
+        char tmp;
 	    int count = -1;
 	    unsigned long *ws;
 
+        printf("%d\n", getpid());
+
         buf1 = malloc(SIZE * getpagesize());
         if (!buf1) {
                 printf("unable to allocate memory\n");
@@ -30,7 +33,7 @@ int main()
                 printf("unable to allocate memory\n");
                 return 1;
         }
-        printf("allocated memory\n");
+        //printf("allocated memory\n");
 
         for (i=0; i<SIZE; i++)
                 buf1[i*getpagesize()] = 'c';
@@ -38,10 +41,23 @@ int main()
                 buf2[i*getpagesize()] = 'c';
         for (i=0; i<SIZE; i++)
                 buf3[i*getpagesize()] = 'c';
-        printf("initialized memory\n");
+        //printf("initialized memory\n");
 
         /**********************************************/
 
+        for (i=0; i<10; i++) {
+                for (j=0; j<SIZE * getpagesize(); j++)
+                        tmp = buf1[j];
+                sleep(1);
+                for (j=0; j<SIZE * getpagesize(); j++)
+                        tmp = buf2[j];
+                sleep(1);
+                for (j=0; j<SIZE * getpagesize(); j++)
+                        tmp = buf3[j];
+                sleep(1);
+        }
+
+/*
         int fd = open("/dev/gunslinger", O_RDWR);
         int pid = getpid();
 
@@ -56,7 +72,7 @@ int main()
         //}
 
 	    read(fd, &count, sizeof(int));
-        printf("count ws: %d\n", count);
+        //printf("count ws: %d\n", count);
 
         ws = malloc(count * sizeof(unsigned long));
         if (!ws) {
@@ -67,11 +83,11 @@ int main()
         read(fd, ws, count * sizeof(unsigned long));
 
         for (i=0; i<count; i++)
-            printf("%lx ", ws[i]);
+            printf("%lx\n", ws[i]);
 
 	    free(ws);
 out:
         close(fd);
-
+*/
         return 0;
 }
diff --git a/test/main.py b/test/main.py
index 5d33b6b..3d47547 100755
--- a/test/main.py
+++ b/test/main.py
@@ -2,27 +2,34 @@
 
 import os
 import sys
+import time
 
-pid = os.getpid().to_bytes(4, byteorder=sys.byteorder)
+#pid = os.getpid().to_bytes(4, byteorder=sys.byteorder)
+pid = int(sys.argv[1]).to_bytes(4, byteorder=sys.byteorder)
 print(pid)
 
 # open device
 fd = os.open('/dev/gunslinger', os.O_RDWR)
 
-# input pid
-os.write(fd, pid)
+wsi = 0
 
-# output result
-count = int.from_bytes(os.read(fd, 4), byteorder=sys.byteorder)
-print('count: {}'.format(count))
+while True:
+    # input pid
+    os.write(fd, pid)
 
-ws = os.read(fd, count * 8)
-wsl = []
+    # output result
+    count = int.from_bytes(os.read(fd, 4), byteorder=sys.byteorder)
+    print('count: {}'.format(count))
 
-for i in range(0, len(ws), 8):
-    wsl.append(int.from_bytes(ws[i:i+8], byteorder=sys.byteorder))
+    ws = os.read(fd, count * 8)
+    with open('ws.{}'.format(wsi), 'w') as out:
+        out.write('{}\n'.format(wsi))
+        for i in range(0, len(ws), 8):
+            out.write('{}\n'.format(int.from_bytes(ws[i:i+8], byteorder=sys.byteorder)))
 
-print(wsl)
+    wsi += 1
+
+    time.sleep(0.5)
 
 # close device
 os.close(fd)
